{
  "version": 3,
  "sources": ["../src/config.ts", "../src/logger.ts", "../src/utils.ts", "../src/tree-generator.ts", "../src/watcher.ts", "../src/architecture-agent.ts", "../src/lm-client.ts", "../src/history.ts", "../src/extension.ts", "../src/token-tracker.ts"],
  "sourcesContent": ["/**\n * @file config.ts\n * @description Configuration loader for `.asciirc.json`.\n *\n * Responsibilities:\n * - Read and parse `.asciirc.json` from the workspace root.\n * - Deep-merge user values over hardcoded defaults.\n * - Validate numeric constraints.\n * - Watch `.asciirc.json` for changes and hot-reload.\n */\n\nimport * as vscode from \"vscode\";\nimport type { AsciiAgentConfig } from \"./types\";\n\n// ---------------------------------------------------------------------------\n// Defaults\n// ---------------------------------------------------------------------------\n\n/**\n * Returns a fresh copy of the default `AsciiAgentConfig`.\n * Called as a factory so each caller gets an independent object (no shared mutation).\n *\n * @returns The default configuration object.\n */\nexport function getDefaultConfig(): AsciiAgentConfig {\n  return {\n    ignore: [\n      \"node_modules\",\n      \".git\",\n      \"dist\",\n      \"out\",\n      \".ascii_history\",\n      \"*.log\",\n      \".DS_Store\",\n      \"yarn.lock\",\n      \"package-lock.json\",\n    ],\n    architectureWatchPatterns: [\"src/**/*.{ts,tsx,js,jsx}\", \"lib/**/*.{ts,tsx,js,jsx}\", \"api/**/*.ts\"],\n    outputPaths: {\n      fileTree: \"docs/file_tree.md\",\n      architecture: \"docs/architecture.md\",\n    },\n    debounceMs: 2000,\n    maxHistorySnapshots: 50,\n    autoWatchEnabled: true,\n    contextFiles: [],\n    filePriority: [],\n    // `tags` is intentionally undefined here \u2014 tree-generator uses its own defaults when absent.\n  };\n}\n\n// ---------------------------------------------------------------------------\n// Loading\n// ---------------------------------------------------------------------------\n\n/**\n * Load the `.asciirc.json` configuration from the workspace root.\n *\n * Loading rules (per PRD \u00A74):\n * 1. Attempt to read `<workspaceRoot>/.asciirc.json` via `vscode.workspace.fs.readFile`.\n * 2. Deep-merge parsed values over defaults.\n * 3. Validate constraints.\n * 4. On malformed JSON, warn the user and fall back to defaults.\n * 5. If the file is absent, silently use defaults.\n *\n * @param workspaceRoot - The URI of the workspace root folder.\n * @returns The fully resolved `AsciiAgentConfig`.\n */\nexport async function loadConfig(workspaceRoot: vscode.Uri): Promise<AsciiAgentConfig> {\n  const configUri = vscode.Uri.joinPath(workspaceRoot, \".asciirc.json\");\n  const defaults = getDefaultConfig();\n\n  let rawText: string;\n  try {\n    const bytes = await vscode.workspace.fs.readFile(configUri);\n    rawText = Buffer.from(bytes).toString(\"utf-8\");\n  } catch {\n    // File doesn't exist \u2014 use defaults silently.\n    return defaults;\n  }\n\n  let parsed: Partial<AsciiAgentConfig>;\n  try {\n    // Strip single-line comments (JSONC support) before parsing.\n    const stripped = stripJsoncComments(rawText);\n    parsed = JSON.parse(stripped) as Partial<AsciiAgentConfig>;\n  } catch (err) {\n    // Malformed JSON \u2014 warn user and fall back to defaults.\n    vscode.window.showWarningMessage(`ASCII Agent: .asciirc.json is malformed \u2014 using defaults. (${String(err)})`);\n    return defaults;\n  }\n\n  // Deep-merge: user values override defaults.\n  const merged = deepMergeConfig(defaults, parsed);\n\n  // Validate constraints (\u00A74).\n  return validateConfig(merged);\n}\n\n// ---------------------------------------------------------------------------\n// Config Watcher\n// ---------------------------------------------------------------------------\n\n/**\n * Watch `.asciirc.json` for changes and invoke `onChange` with the reloaded config.\n * The returned `Disposable` should be added to `context.subscriptions`.\n *\n * @param workspaceRoot - URI of the workspace root folder.\n * @param onChange      - Callback invoked with the new config whenever the file changes.\n * @returns A disposable that stops watching when disposed.\n */\nexport function watchConfigFile(\n  workspaceRoot: vscode.Uri,\n  onChange: (cfg: AsciiAgentConfig) => void,\n): vscode.Disposable {\n  // Watch only the specific config file.\n  const pattern = new vscode.RelativePattern(workspaceRoot, \".asciirc.json\");\n  const watcher = vscode.workspace.createFileSystemWatcher(pattern);\n\n  const reload = async () => {\n    const cfg = await loadConfig(workspaceRoot);\n    onChange(cfg);\n  };\n\n  // Handle creation, modification, and deletion of the config file.\n  const onCreate = watcher.onDidCreate(reload);\n  const onChange_ = watcher.onDidChange(reload);\n  const onDelete = watcher.onDidDelete(async () => {\n    // If deleted, revert to defaults.\n    onChange(getDefaultConfig());\n  });\n\n  return {\n    dispose: () => {\n      watcher.dispose();\n      onCreate.dispose();\n      onChange_.dispose();\n      onDelete.dispose();\n    },\n  };\n}\n\n// ---------------------------------------------------------------------------\n// Helpers (private)\n// ---------------------------------------------------------------------------\n\n/**\n * Deep-merge two `AsciiAgentConfig`-shaped objects.\n * Array fields from `overrides` fully replace those in `base` (no array concat).\n * Nested objects (`outputPaths`) are merged shallowly.\n *\n * @param base      - The default config.\n * @param overrides - The user-provided partial config.\n * @returns The merged config.\n */\nfunction deepMergeConfig(base: AsciiAgentConfig, overrides: Partial<AsciiAgentConfig>): AsciiAgentConfig {\n  return {\n    ignore: overrides.ignore !== undefined ? overrides.ignore : base.ignore,\n    architectureWatchPatterns:\n      overrides.architectureWatchPatterns !== undefined\n        ? overrides.architectureWatchPatterns\n        : base.architectureWatchPatterns,\n    outputPaths:\n      overrides.outputPaths !== undefined ? { ...base.outputPaths, ...overrides.outputPaths } : base.outputPaths,\n    debounceMs: overrides.debounceMs !== undefined ? overrides.debounceMs : base.debounceMs,\n    maxHistorySnapshots:\n      overrides.maxHistorySnapshots !== undefined ? overrides.maxHistorySnapshots : base.maxHistorySnapshots,\n    autoWatchEnabled: overrides.autoWatchEnabled !== undefined ? overrides.autoWatchEnabled : base.autoWatchEnabled,\n    contextFiles: overrides.contextFiles !== undefined ? overrides.contextFiles : base.contextFiles,\n    filePriority: overrides.filePriority !== undefined ? overrides.filePriority : base.filePriority,\n    // `tags` is optional \u2014 only set if user explicitly provided it.\n    tags: overrides.tags !== undefined ? overrides.tags : base.tags,\n  };\n}\n\n/**\n * Validate numeric constraints on the config per PRD \u00A74.\n * Mutates the config in place and returns it for chaining.\n *\n * @param cfg - The config to validate.\n * @returns The (possibly corrected) config.\n */\nfunction validateConfig(cfg: AsciiAgentConfig): AsciiAgentConfig {\n  if (cfg.debounceMs < 500) {\n    vscode.window.showWarningMessage(\"ASCII Agent: debounceMs must be \u2265 500. Resetting to 500.\");\n    cfg.debounceMs = 500;\n  }\n  if (cfg.maxHistorySnapshots < 1) {\n    vscode.window.showWarningMessage(\"ASCII Agent: maxHistorySnapshots must be \u2265 1. Resetting to 1.\");\n    cfg.maxHistorySnapshots = 1;\n  }\n  return cfg;\n}\n\n/**\n * Strip single-line (`//`) comments from a JSONC string so `JSON.parse` can handle it.\n * This is a minimal implementation \u2014 it does not handle block comments (C-style slash-star pairs).\n *\n * @param text - Raw JSONC text.\n * @returns JSON text with `//` comments removed.\n */\nfunction stripJsoncComments(text: string): string {\n  // Remove everything from `//` to end-of-line, but not inside string literals.\n  // A proper JSONC parser would handle edge cases like `//` inside strings,\n  // but for a config file this lightweight approach is sufficient.\n  return text.replace(/\\/\\/[^\\n]*/g, \"\");\n}\n", "/**\n * @file logger.ts\n * @description Singleton output channel for all ASCII Agent diagnostic logging.\n *\n * All modules import from this file instead of `extension.ts` to avoid circular\n * dependencies. The output channel is initialized by `extension.ts` on activation\n * via `initLogger()`, and is a no-op until initialized.\n *\n * Usage:\n *   import { log } from './logger';\n *   log.info('Hello');\n *   log.warn('Something odd happened');\n *   log.error('Something broke');\n */\n\nimport * as vscode from \"vscode\";\n\n// The single shared output channel instance.\nlet _channel: vscode.OutputChannel | undefined;\n\n/**\n * Initialize the logger with the given output channel.\n * Must be called once from `extension.ts` during `activate()`.\n *\n * @param channel - The already-created output channel.\n */\nexport function initLogger(channel: vscode.OutputChannel): void {\n  _channel = channel;\n}\n\n/**\n * Logging helpers.\n * All methods are no-ops if the logger has not been initialized yet.\n */\nexport const log = {\n  /**\n   * Log an informational message.\n   * @param message - The message to log.\n   */\n  info(message: string): void {\n    _channel?.appendLine(`[INFO]  ${message}`);\n  },\n\n  /**\n   * Log a warning message.\n   * @param message - The message to log.\n   */\n  warn(message: string): void {\n    _channel?.appendLine(`[WARN]  ${message}`);\n  },\n\n  /**\n   * Log an error message.\n   * @param message - The message to log.\n   */\n  error(message: string): void {\n    _channel?.appendLine(`[ERROR] ${message}`);\n  },\n\n  /**\n   * Log a raw message with no prefix \u2014 for structured output (e.g. command output).\n   * @param message - The message to log.\n   */\n  raw(message: string): void {\n    _channel?.appendLine(message);\n  },\n};\n\n/**\n * Expose the raw channel for cases where callers need direct access\n * (e.g. to push into `context.subscriptions`).\n */\nexport function getOutputChannel(): vscode.OutputChannel | undefined {\n  return _channel;\n}\n", "/**\n * @file utils.ts\n * @description Shared utility functions for ASCII Agent.\n *\n * Stub \u2014 full implementation in Phase 2.\n */\n\nimport * as vscode from \"vscode\";\n\n/**\n * Test a workspace-relative file path against an array of glob patterns.\n *\n * @param filePath - Workspace-relative path to test (e.g. \"src/app.tsx\").\n * @param patterns - Array of glob patterns to match against.\n * @returns `true` if the path matches at least one pattern.\n */\nexport function matchesAnyPattern(filePath: string, patterns: string[]): boolean {\n  return patterns.some((pattern) => minimatch(filePath, pattern));\n}\n\n/**\n * Convert an absolute `vscode.Uri` to a workspace-relative string.\n *\n * @param uri           - Absolute URI to convert.\n * @param workspaceRoot - URI of the workspace root.\n * @returns Workspace-relative path (e.g. \"src/app.tsx\"), without leading slash.\n */\nexport function workspaceRelativePath(uri: vscode.Uri, workspaceRoot: vscode.Uri): string {\n  const rootPath = workspaceRoot.fsPath.replace(/\\\\/g, \"/\").replace(/\\/$/, \"\");\n  const filePath = uri.fsPath.replace(/\\\\/g, \"/\");\n  return filePath.startsWith(rootPath + \"/\") ? filePath.slice(rootPath.length + 1) : filePath;\n}\n\n/**\n * Create a directory (and all intermediate parents) if it does not already exist.\n * Equivalent to `mkdir -p`.\n *\n * @param uri - Absolute URI of the directory to create.\n */\nexport async function ensureDirectoryExists(uri: vscode.Uri): Promise<void> {\n  try {\n    await vscode.workspace.fs.createDirectory(uri);\n  } catch {\n    // createDirectory is idempotent on most platforms; ignore errors if already exists.\n    // Any real I/O error will surface when we subsequently try to write files.\n  }\n}\n\n// ---------------------------------------------------------------------------\n// Minimal glob matching (no npm dependencies)\n// ---------------------------------------------------------------------------\n\n/**\n * Minimal glob pattern matcher.\n *\n * Supports the following syntax:\n * - `*`  \u2014 matches any sequence of characters within a path segment (not `/`).\n * - `**` \u2014 matches any sequence of characters including `/` (zero or more path segments).\n * - `?`  \u2014 matches any single character except `/`.\n * - `{a,b}` \u2014 brace expansion (simple comma-separated alternatives).\n * - Character classes like `{ts,tsx}`.\n *\n * This is intentionally minimal \u2014 sufficient for the glob patterns used in `.asciirc.json`.\n * Full POSIX glob semantics are NOT required.\n *\n * @param path    - The path to test.\n * @param pattern - The glob pattern.\n * @returns `true` if `path` matches `pattern`.\n */\nfunction minimatch(path: string, pattern: string): boolean {\n  // Normalize path separators to forward slashes.\n  const normalizedPath = path.replace(/\\\\/g, \"/\");\n\n  // Expand brace expressions like `{ts,tsx,js}` into alternatives.\n  const patterns = expandBraces(pattern);\n\n  return patterns.some((p) => matchGlob(normalizedPath, p));\n}\n\n/**\n * Expand brace expressions in a glob pattern into an array of patterns.\n * E.g. `src/**\\/*.{ts,tsx}` \u2192 `[\"src/**\\/*.ts\", \"src/**\\/*.tsx\"]`\n *\n * @param pattern - Glob pattern possibly containing `{a,b,c}`.\n * @returns Array of expanded patterns.\n */\nfunction expandBraces(pattern: string): string[] {\n  const match = /\\{([^{}]*)\\}/.exec(pattern);\n  if (!match) {\n    return [pattern];\n  }\n\n  const alternatives = match[1].split(\",\");\n  const results: string[] = [];\n\n  for (const alt of alternatives) {\n    const expanded = pattern.slice(0, match.index) + alt + pattern.slice(match.index + match[0].length);\n    // Recursively expand nested braces.\n    results.push(...expandBraces(expanded));\n  }\n\n  return results;\n}\n\n/**\n * Match a path against a single (already brace-expanded) glob pattern.\n * Converts the glob to a regular expression and tests.\n *\n * @param path    - Normalized path.\n * @param pattern - A single glob pattern (no braces).\n * @returns `true` if the path matches.\n */\nfunction matchGlob(path: string, pattern: string): boolean {\n  // Convert glob to regex:\n  // 1. Escape regex special chars (except * and ?).\n  // 2. Replace `**` with a sentinel, then `*` with `[^/]*`, then restore `**` as `.*`.\n  // 3. Replace `?` with `[^/]`.\n  let regexStr = pattern\n    .replace(/[.+^${}()|[\\]\\\\]/g, \"\\\\$&\") // Escape regex specials (not * or ?)\n    .replace(/\\*\\*/g, \"\\u0001DOUBLESTAR\\u0001\") // Sentinel for **\n    .replace(/\\*/g, \"[^/]*\") // * \u2192 any chars except /\n    .replace(/\\u0001DOUBLESTAR\\u0001/g, \".*\") // ** \u2192 any chars including /\n    .replace(/\\?/g, \"[^/]\"); // ? \u2192 any single char except /\n\n  // Anchor the pattern.\n  // If the pattern has no `/`, match against the basename only.\n  if (!pattern.includes(\"/\")) {\n    // Match the filename at any depth.\n    regexStr = \"(^|.*/)(\" + regexStr + \")$\";\n  } else {\n    regexStr = \"^\" + regexStr + \"$\";\n  }\n\n  try {\n    return new RegExp(regexStr).test(path);\n  } catch {\n    return false;\n  }\n}\n", "/**\n * @file tree-generator.ts\n * @description Pure function: workspace \u2192 file_tree.txt string.\n *\n * This module is PURE \u2014 no AI, no LM calls. It walks the file system\n * and produces the ASCII tree string.\n *\n * Full implementation \u2014 see PRD \u00A75.4.\n */\n\nimport * as vscode from \"vscode\";\nimport type { AsciiAgentConfig } from \"./types\";\nimport { matchesAnyPattern } from \"./utils\";\n\n// ---------------------------------------------------------------------------\n// Constants\n// ---------------------------------------------------------------------------\n\n/** Maximum number of file-tree entries before truncation (PRD \u00A77.6). */\nconst MAX_ENTRIES = 5000;\n\n/**\n * Default tag map: maps glob patterns to inline tag strings.\n * Used when `config.tags` is not provided.\n * Keys are generic \u2014 no project-specific paths.\n */\nconst DEFAULT_TAGS: Record<string, string> = {\n  \"*.config.*\": \"[config]\",\n  \"*.json\": \"[config]\",\n  \"src/components/**\": \"[ui]\",\n  \"src/**\": \"[source]\",\n  \"lib/**\": \"[source]\",\n  \"api/**\": \"[backend]\",\n  \"docs/**\": \"[docs]\",\n  \"test/**\": \"[test]\",\n  \"scripts/**\": \"[script]\",\n};\n\n// ---------------------------------------------------------------------------\n// Public API\n// ---------------------------------------------------------------------------\n\n/**\n * Generate the ASCII file-tree string for the given workspace.\n *\n * Algorithm (PRD \u00A75.4):\n * 1. Recursively read directory entries via `vscode.workspace.fs.readDirectory`.\n * 2. Filter out entries matching `ignore` patterns.\n * 3. Sort: directories first (alphabetical), then files (alphabetical).\n * 4. Format with `\u251C\u2500\u2500`, `\u2514\u2500\u2500`, `\u2502   ` box-drawing characters.\n * 5. Append inline tags based on the tag map (config.tags or defaults).\n * 6. Prepend the workspace folder name as the root node.\n *\n * Note: File I/O is performed \u2014 do NOT write to disk. Caller handles I/O.\n *\n * @param workspaceRoot - Absolute URI of the workspace root folder.\n * @param config        - The active `AsciiAgentConfig` (for ignore patterns and tags).\n * @returns The complete ASCII tree as a single string.\n */\nexport async function generateFileTree(workspaceRoot: vscode.Uri, config: AsciiAgentConfig): Promise<string> {\n  // Determine which tag map to use (user-provided replaces defaults entirely).\n  const tagMap: Record<string, string> = config.tags ?? DEFAULT_TAGS;\n\n  // Counter to enforce the MAX_ENTRIES cap.\n  let entryCount = 0;\n  let truncated = false;\n\n  /**\n   * Recursively build tree lines for a directory.\n   *\n   * @param dirUri   - Absolute URI of the directory to walk.\n   * @param relPath  - Workspace-relative path of this directory (for ignore-pattern matching).\n   * @param prefix   - Current line-drawing prefix (built up as we recurse).\n   * @returns Array of formatted tree lines.\n   */\n  async function buildLines(dirUri: vscode.Uri, relPath: string, prefix: string): Promise<string[]> {\n    if (truncated) {\n      return [];\n    }\n\n    let entries: [string, vscode.FileType][];\n    try {\n      entries = await vscode.workspace.fs.readDirectory(dirUri);\n    } catch {\n      // Unreadable directory \u2014 skip silently.\n      return [];\n    }\n\n    // Filter out ignored entries.\n    const filtered = entries.filter(([name]) => {\n      const entryRelPath = relPath ? `${relPath}/${name}` : name;\n      return !matchesAnyPattern(entryRelPath, config.ignore) && !matchesAnyPattern(name, config.ignore);\n    });\n\n    // Sort: directories first (alphabetical), then files (alphabetical).\n    const sorted = filtered.sort(([nameA, typeA], [nameB, typeB]) => {\n      const aIsDir = typeA === vscode.FileType.Directory;\n      const bIsDir = typeB === vscode.FileType.Directory;\n      if (aIsDir !== bIsDir) {\n        return aIsDir ? -1 : 1;\n      }\n      return nameA.localeCompare(nameB);\n    });\n\n    const lines: string[] = [];\n\n    for (let i = 0; i < sorted.length; i++) {\n      if (truncated) {\n        break;\n      }\n\n      const [name, type] = sorted[i];\n      const isLast = i === sorted.length - 1;\n      const entryRelPath = relPath ? `${relPath}/${name}` : name;\n\n      // Box-drawing characters for tree structure.\n      const connector = isLast ? \"\u2514\u2500\u2500 \" : \"\u251C\u2500\u2500 \";\n      const childPrefix = isLast ? \"    \" : \"\u2502   \";\n\n      entryCount++;\n      if (entryCount > MAX_ENTRIES) {\n        // Count remaining entries to report in truncation message.\n        const remaining = sorted.length - i;\n        lines.push(`${prefix}... (truncated: ${remaining} more entries not shown)`);\n        truncated = true;\n        break;\n      }\n\n      if (type === vscode.FileType.Directory) {\n        lines.push(`${prefix}${connector}${name}/`);\n        // Recurse into subdirectory.\n        const childLines = await buildLines(vscode.Uri.joinPath(dirUri, name), entryRelPath, prefix + childPrefix);\n        lines.push(...childLines);\n      } else {\n        // Determine inline tag for this file.\n        const tag = resolveTag(entryRelPath, tagMap);\n        const tagSuffix = tag ? `  ${tag}` : \"\";\n        lines.push(`${prefix}${connector}${name}${tagSuffix}`);\n      }\n    }\n\n    return lines;\n  }\n\n  // Build all lines starting from the workspace root.\n  const rootName = workspaceRoot.path.split(\"/\").pop() ?? workspaceRoot.fsPath.split(\"/\").pop() ?? \"workspace\";\n  const bodyLines = await buildLines(workspaceRoot, \"\", \"\");\n\n  // Compose raw ASCII tree with root node at top.\n  const allLines = [rootName + \"/\", ...bodyLines];\n  const rawTree = allLines.join(\"\\n\");\n\n  // Wrap in a markdown code block so the .md file renders correctly in\n  // VS Code preview, GitHub, and is well-understood by AI agents.\n  return `# File Tree\\n\\n\\`\\`\\`\\n${rawTree}\\n\\`\\`\\`\\n`;\n}\n\n// ---------------------------------------------------------------------------\n// Helpers (private)\n// ---------------------------------------------------------------------------\n\n/**\n * Resolve the tag string for a workspace-relative file path.\n * Tests the path against each entry in `tagMap` (in insertion order) and\n * returns the first matching tag. Returns `undefined` if no match.\n *\n * @param relPath - Workspace-relative path to the file.\n * @param tagMap  - Map of glob-pattern \u2192 tag string.\n * @returns The matched tag string, or `undefined`.\n */\nfunction resolveTag(relPath: string, tagMap: Record<string, string>): string | undefined {\n  for (const [pattern, tag] of Object.entries(tagMap)) {\n    if (matchesAnyPattern(relPath, [pattern])) {\n      return tag;\n    }\n  }\n  return undefined;\n}\n", "/**\n * @file watcher.ts\n * @description FileSystemWatcher orchestration with debounce timers.\n *\n * Responsibilities (PRD \u00A75.3):\n * - Create a single `FileSystemWatcher` on `**\\/*` within the workspace.\n * - On create/delete/change events:\n *   (a) Skip if path matches `ignore` patterns.\n *   (b) Skip if path is an output file or `.ascii_history/**` (self-write loop prevention).\n *   (c) Always schedule a debounced file-tree regeneration.\n *   (d) If the path matches `architectureWatchPatterns`, also schedule a debounced\n *       architecture regeneration.\n * - Maintain two INDEPENDENT debounce timers (tree vs. architecture).\n *\n * Critical edge cases handled:\n * - Burst protection: debounce timer resets on every event; fires only after sustained silence.\n * - Self-write loop: output files and history dir are explicitly excluded.\n */\n\nimport * as vscode from \"vscode\";\nimport type { AsciiAgentConfig, WatcherHandlers, WatcherSession } from \"./types\";\nimport { matchesAnyPattern, workspaceRelativePath } from \"./utils\";\nimport { log } from \"./logger\";\n\n// ---------------------------------------------------------------------------\n// Module-level debounce timer handles (shared so extension.ts can cancel them)\n// ---------------------------------------------------------------------------\n\n/** Timer handle for the pending file-tree regeneration. */\nlet treeDebounceTimer: ReturnType<typeof setTimeout> | undefined;\n\n/** Timer handle for the pending architecture regeneration. */\nlet archDebounceTimer: ReturnType<typeof setTimeout> | undefined;\n\n// ---------------------------------------------------------------------------\n// Public API\n// ---------------------------------------------------------------------------\n\n/**\n * Start watching the workspace for file changes.\n *\n * Creates a `vscode.FileSystemWatcher` on all files (`**\\/*`) and wires up\n * the debounced regeneration handlers.\n *\n * @param config   - Active `AsciiAgentConfig` (ignore patterns, watch patterns, debounceMs).\n * @param context  - Extension context (unused directly; kept for API symmetry and future use).\n * @param handlers - Callbacks invoked when debounce timers expire.\n * @returns A `WatcherSession` whose `dispose()` tears everything down.\n */\nexport function startWatching(\n  config: AsciiAgentConfig,\n  context: vscode.ExtensionContext,\n  handlers: WatcherHandlers,\n): WatcherSession {\n  const workspaceFolders = vscode.workspace.workspaceFolders;\n  if (!workspaceFolders || workspaceFolders.length === 0) {\n    log.warn(\"startWatching: no workspace folder \u2014 aborting.\");\n    return { dispose: () => undefined };\n  }\n\n  const workspaceRoot = workspaceFolders[0].uri;\n\n  // Watch all files in the workspace (broad pattern; filtering done in the event handler).\n  const watcher = vscode.workspace.createFileSystemWatcher(new vscode.RelativePattern(workspaceRoot, \"**/*\"));\n\n  /**\n   * Build the set of paths that should NEVER trigger regeneration.\n   * Pre-compute once when the watcher starts (config-driven).\n   */\n  const outputFilePaths = new Set([config.outputPaths.fileTree, config.outputPaths.architecture]);\n\n  /**\n   * Determine whether a file-system event should be processed.\n   *\n   * Returns `'ignore'` if the event should be skipped entirely.\n   * Returns `'tree-only'` if only the file tree should be regenerated.\n   * Returns `'tree-and-arch'` if both tree and architecture should be regenerated.\n   *\n   * @param uri - The URI of the changed file.\n   */\n  function classifyEvent(uri: vscode.Uri): \"ignore\" | \"tree-only\" | \"tree-and-arch\" {\n    const relPath = workspaceRelativePath(uri, workspaceRoot);\n\n    // --- Self-write loop prevention (PRD \u00A75.3) ---\n    // Skip changes to the output files themselves.\n    if (outputFilePaths.has(relPath)) {\n      return \"ignore\";\n    }\n    // Skip changes inside .ascii_history/.\n    if (relPath.startsWith(\".ascii_history/\") || relPath === \".ascii_history\") {\n      return \"ignore\";\n    }\n\n    // --- Ignore-pattern matching ---\n    if (matchesAnyPattern(relPath, config.ignore) || matchesAnyPattern(relPath.split(\"/\").pop() ?? \"\", config.ignore)) {\n      return \"ignore\";\n    }\n\n    // --- Architecture watch pattern matching ---\n    if (matchesAnyPattern(relPath, config.architectureWatchPatterns)) {\n      return \"tree-and-arch\";\n    }\n\n    return \"tree-only\";\n  }\n\n  /**\n   * Schedule (or reset) the debounced file-tree regeneration.\n   */\n  function scheduleTreeRegen(): void {\n    if (treeDebounceTimer !== undefined) {\n      clearTimeout(treeDebounceTimer);\n    }\n    treeDebounceTimer = setTimeout(async () => {\n      treeDebounceTimer = undefined;\n      log.info(\"Debounce expired \u2014 regenerating file tree.\");\n      try {\n        await handlers.onTreeRegenNeeded();\n      } catch (err) {\n        log.error(`Tree regen failed: ${String(err)}`);\n      }\n    }, config.debounceMs);\n  }\n\n  /**\n   * Schedule (or reset) the debounced architecture regeneration.\n   */\n  function scheduleArchRegen(): void {\n    if (archDebounceTimer !== undefined) {\n      clearTimeout(archDebounceTimer);\n    }\n    archDebounceTimer = setTimeout(async () => {\n      archDebounceTimer = undefined;\n      log.info(\"Debounce expired \u2014 regenerating architecture diagram.\");\n      try {\n        await handlers.onArchitectureRegenNeeded();\n      } catch (err) {\n        log.error(`Architecture regen failed: ${String(err)}`);\n      }\n    }, config.debounceMs);\n  }\n\n  /**\n   * Shared handler for all three watcher events (create, change, delete).\n   *\n   * @param uri - URI of the affected file.\n   */\n  function handleEvent(uri: vscode.Uri): void {\n    const classification = classifyEvent(uri);\n\n    if (classification === \"ignore\") {\n      return;\n    }\n\n    scheduleTreeRegen();\n\n    if (classification === \"tree-and-arch\") {\n      scheduleArchRegen();\n    }\n  }\n\n  // Wire up all three watcher events.\n  const onCreate = watcher.onDidCreate(handleEvent);\n  const onChange = watcher.onDidChange(handleEvent);\n  const onDelete = watcher.onDidDelete(handleEvent);\n\n  log.info(`Watcher started. debounceMs=${config.debounceMs}`);\n\n  return {\n    dispose: () => {\n      // Cancel any pending timers.\n      if (treeDebounceTimer !== undefined) {\n        clearTimeout(treeDebounceTimer);\n        treeDebounceTimer = undefined;\n      }\n      if (archDebounceTimer !== undefined) {\n        clearTimeout(archDebounceTimer);\n        archDebounceTimer = undefined;\n      }\n      // Dispose VS Code watcher and event subscriptions.\n      onCreate.dispose();\n      onChange.dispose();\n      onDelete.dispose();\n      watcher.dispose();\n      log.info(\"Watcher stopped.\");\n    },\n  };\n}\n\n/**\n * Stop a watcher session by calling its dispose method.\n * Convenience wrapper that handles `undefined` sessions gracefully.\n *\n * @param session - The session to stop.\n */\nexport function stopWatching(session: WatcherSession): void {\n  session.dispose();\n}\n\n/**\n * Cancel any pending debounce timers without disposing the watcher.\n * Used by `asciiAgent.generateNow` to pre-empt a pending debounced regeneration (PRD \u00A77.5).\n */\nexport function cancelPendingTimers(): void {\n  if (treeDebounceTimer !== undefined) {\n    clearTimeout(treeDebounceTimer);\n    treeDebounceTimer = undefined;\n  }\n  if (archDebounceTimer !== undefined) {\n    clearTimeout(archDebounceTimer);\n    archDebounceTimer = undefined;\n  }\n}\n", "/**\n * @file architecture-agent.ts\n * @description LM-powered architecture diagram generator.\n *\n * Flow (PRD \u00A75.5):\n * 1. Gather context: read files matching `architectureWatchPatterns` (within token budget).\n * 2. Read the current architecture output (if it exists) as \"previous version.\"\n * 3. Optionally read `contextFiles` from config.\n * 4. Construct a system prompt, injecting workspace folder name dynamically.\n * 5. Call `vscode.lm` via `LmClient`.\n * 6. Post-process: strip markdown fences / preamble text from the response.\n * 7. Return the cleaned diagram string (caller handles disk I/O).\n */\n\nimport * as vscode from \"vscode\";\nimport type { AsciiAgentConfig, LmClient, ArchitectureGenerationResult } from \"./types\";\nimport { matchesAnyPattern } from \"./utils\";\nimport { log } from \"./logger\";\n\n// ---------------------------------------------------------------------------\n// Constants\n// ---------------------------------------------------------------------------\n\n/**\n * Fraction of the model's `maxInputTokens` budget reserved for source code context.\n * The remaining 20% is for system instructions and response headroom.\n */\nconst INPUT_BUDGET_FRACTION = 0.8;\n\n// ---------------------------------------------------------------------------\n// System Prompt Template\n// ---------------------------------------------------------------------------\n\n/**\n * System prompt template string.\n * Placeholders (all replaced dynamically at runtime \u2014 never hardcoded):\n * - `{workspace_folder_name}` \u2014 basename of the workspace root folder.\n * - `{previous_architecture}` \u2014 content of current `docs/architecture.txt` (or \"N/A\").\n * - `{context_files_content}` \u2014 concatenated content of `config.contextFiles` (or \"N/A\").\n * - `{source_files_content}` \u2014 concatenated source files within token budget.\n */\nconst SYSTEM_PROMPT_TEMPLATE = `You are an ASCII architecture diagram generator for the software project \"{workspace_folder_name}\".\n\nYour job is to produce a CONCEPTUAL data-flow diagram in pure ASCII art. The diagram must show:\n- Major logical modules and their responsibilities\n- Data flow between modules (arrows: ---> )\n- State management cycles\n- External API interactions\n- Feedback loops\n\nRULES:\n1. Output ONLY the ASCII diagram. No markdown fences, no explanation text before or after.\n2. Use box-drawing characters: +, -, |, > for arrows.\n3. Keep column width under 100 characters.\n4. Include a \"Feedback loops:\" text section at the bottom listing cyclic dependencies.\n5. Do NOT include file paths or directory structure. This is a CONCEPTUAL diagram, not a physical one.\n6. If a previous diagram is provided, preserve its general layout and only update sections that have changed based on the new source code. Do not gratuitously reorganize.\n\nPREVIOUS DIAGRAM:\n{previous_architecture}\n\nPROJECT CONTEXT (if available):\n{context_files_content}\n\nSOURCE CODE CONTEXT:\n{source_files_content}\n\nGenerate the updated architecture diagram now.`;\n\n// ---------------------------------------------------------------------------\n// Public API\n// ---------------------------------------------------------------------------\n\n/**\n * Generate the architecture diagram using the Copilot LM.\n *\n * @param config        - Active `AsciiAgentConfig` (watch patterns, context files, etc.)\n * @param workspaceRoot - Absolute URI of the workspace root.\n * @param lmClient      - Initialized `LmClient` instance to use for the LM call.\n * @param token         - Optional external cancellation token (e.g. from progress dialog).\n * @returns An `ArchitectureGenerationResult` containing the diagram and token-usage estimates.\n */\nexport async function generateArchitectureDiagram(\n  config: AsciiAgentConfig,\n  workspaceRoot: vscode.Uri,\n  lmClient: LmClient,\n  token?: vscode.CancellationToken,\n): Promise<ArchitectureGenerationResult> {\n  // 1. Select the model to determine token budget.\n  const models = await vscode.lm.selectChatModels({ vendor: \"copilot\" });\n  const model = models[0];\n  const tokenBudget = model ? Math.floor(model.maxInputTokens * INPUT_BUDGET_FRACTION) : 8000; // Fallback budget if model metadata is unavailable.\n\n  // 2. Gather source file context within token budget.\n  const sourceContent = await gatherSourceContext(config, workspaceRoot, tokenBudget, model);\n\n  // 3. Read previous architecture diagram (if it exists).\n  const previousArchitecture = await readPreviousArchitecture(config, workspaceRoot);\n\n  // 4. Read optional context files.\n  const contextFilesContent = await readContextFiles(config, workspaceRoot);\n\n  // 5. Derive workspace folder name dynamically \u2014 never hardcoded.\n  const workspaceFolderName =\n    workspaceRoot.path.split(\"/\").filter(Boolean).pop() ??\n    workspaceRoot.fsPath.split(/[\\\\/]/).filter(Boolean).pop() ??\n    \"workspace\";\n\n  // 6. Build the prompt by substituting all template placeholders.\n  const promptText = SYSTEM_PROMPT_TEMPLATE.replace(\"{workspace_folder_name}\", workspaceFolderName)\n    .replace(\"{previous_architecture}\", previousArchitecture || \"N/A\")\n    .replace(\"{context_files_content}\", contextFilesContent || \"N/A\")\n    .replace(\"{source_files_content}\", sourceContent || \"N/A\");\n\n  log.info(`Sending architecture prompt (~${promptText.length} chars) to LM.`);\n\n  // 7. Send the prompt to the LM.\n  const messages = [vscode.LanguageModelChatMessage.User(promptText)];\n\n  const rawResponse = await lmClient.sendPrompt(messages, token);\n\n  // 8. Post-process: strip markdown fences and any preamble text from LM response.\n  const cleaned = postProcessResponse(rawResponse);\n\n  log.info(`Architecture diagram received (${cleaned.length} chars).`);\n\n  // 9. Wrap in a markdown code block so the .md file renders correctly in\n  //    VS Code preview, GitHub, and is well-understood by AI agents.\n  const diagram = `# Architecture Diagram\\n\\n\\`\\`\\`\\n${cleaned.trimEnd()}\\n\\`\\`\\`\\n`;\n\n  return {\n    diagram,\n    inputTokensEstimate: Math.ceil(promptText.length / 4),\n    outputTokensEstimate: Math.ceil(rawResponse.length / 4),\n  };\n}\n\n// ---------------------------------------------------------------------------\n// Context gathering\n// ---------------------------------------------------------------------------\n\n/**\n * Gather source file content for the LM prompt, respecting the token budget.\n *\n * Priority order (PRD \u00A75.5.2):\n * 1. Files matching `config.filePriority` glob patterns (in order).\n * 2. Heuristic fallback: `contextFiles`, then `src/`/`lib/` roots, then alphabetical.\n *\n * If the model supports `countTokens`, use it to measure. Otherwise use a\n * character-count heuristic (~4 chars per token).\n *\n * @param config        - Active config.\n * @param workspaceRoot - Workspace root URI.\n * @param tokenBudget   - Max tokens available for source content.\n * @param model         - LM model (for `countTokens`), may be undefined.\n * @returns Concatenated source file contents, possibly truncated.\n */\nasync function gatherSourceContext(\n  config: AsciiAgentConfig,\n  workspaceRoot: vscode.Uri,\n  tokenBudget: number,\n  model: vscode.LanguageModelChat | undefined,\n): Promise<string> {\n  // Collect all files matching architectureWatchPatterns.\n  const allCandidates = await collectCandidateFiles(config, workspaceRoot);\n\n  // Sort candidates by priority.\n  const prioritized = prioritizeFiles(allCandidates, config);\n\n  // Read and accumulate within token budget.\n  const sections: string[] = [];\n  let usedTokens = 0;\n\n  for (const relPath of prioritized) {\n    const fileUri = vscode.Uri.joinPath(workspaceRoot, relPath);\n    let content: string;\n    try {\n      const bytes = await vscode.workspace.fs.readFile(fileUri);\n      content = Buffer.from(bytes).toString(\"utf-8\");\n    } catch {\n      continue; // Skip unreadable files.\n    }\n\n    const fileSection = `// File: ${relPath}\\n${content}\\n`;\n\n    // Estimate token count.\n    const tokenCount = model ? await safeCountTokens(model, fileSection) : Math.ceil(fileSection.length / 4);\n\n    if (usedTokens + tokenCount > tokenBudget) {\n      log.info(`Token budget reached. Skipping ${relPath} and remaining files.`);\n      break; // Stop adding files.\n    }\n\n    sections.push(fileSection);\n    usedTokens += tokenCount;\n  }\n\n  return sections.join(\"\\n---\\n\");\n}\n\n/**\n * Collect all files in the workspace that match any `architectureWatchPatterns` glob,\n * excluding paths matching `ignore` patterns.\n *\n * @param config        - Active config.\n * @param workspaceRoot - Workspace root URI.\n * @returns Sorted list of workspace-relative file paths.\n */\nasync function collectCandidateFiles(config: AsciiAgentConfig, workspaceRoot: vscode.Uri): Promise<string[]> {\n  const candidates: string[] = [];\n\n  /** Recursively walk a directory, collecting matching files. */\n  async function walk(dirUri: vscode.Uri, relBase: string): Promise<void> {\n    let entries: [string, vscode.FileType][];\n    try {\n      entries = await vscode.workspace.fs.readDirectory(dirUri);\n    } catch {\n      return;\n    }\n\n    for (const [name, type] of entries) {\n      const relPath = relBase ? `${relBase}/${name}` : name;\n\n      // Skip ignored paths.\n      if (matchesAnyPattern(relPath, config.ignore) || matchesAnyPattern(name, config.ignore)) {\n        continue;\n      }\n\n      if (type === vscode.FileType.Directory) {\n        await walk(vscode.Uri.joinPath(dirUri, name), relPath);\n      } else if (type === vscode.FileType.File) {\n        // Include if it matches any architectureWatchPattern.\n        if (matchesAnyPattern(relPath, config.architectureWatchPatterns)) {\n          candidates.push(relPath);\n        }\n      }\n    }\n  }\n\n  await walk(workspaceRoot, \"\");\n  return candidates.sort();\n}\n\n/**\n * Sort candidate file paths by priority (PRD \u00A75.5.2).\n *\n * If `config.filePriority` is non-empty, use that ordering.\n * Otherwise use heuristic: `contextFiles` first, then `src/`/`lib/` roots, then alphabetical.\n *\n * @param candidates - All candidate file paths.\n * @param config     - Active config.\n * @returns Re-ordered list.\n */\nfunction prioritizeFiles(candidates: string[], config: AsciiAgentConfig): string[] {\n  if (config.filePriority.length > 0) {\n    // Priority-ordered: assign a score based on which filePriority pattern matches first.\n    return [...candidates].sort((a, b) => {\n      const scoreA = getPriorityScore(a, config.filePriority);\n      const scoreB = getPriorityScore(b, config.filePriority);\n      // Lower score = higher priority.\n      if (scoreA !== scoreB) {\n        return scoreA - scoreB;\n      }\n      return a.localeCompare(b);\n    });\n  }\n\n  // Generic heuristic (PRD \u00A75.5.2):\n  // 1. contextFiles (if they appear in candidates)\n  // 2. src/ or lib/ root-level files (depth 2)\n  // 3. Everything else alphabetically.\n  const contextSet = new Set(config.contextFiles);\n\n  return [...candidates].sort((a, b) => {\n    const aScore = heuristicScore(a, contextSet);\n    const bScore = heuristicScore(b, contextSet);\n    if (aScore !== bScore) {\n      return aScore - bScore;\n    }\n    return a.localeCompare(b);\n  });\n}\n\n/**\n * Return the priority score for a path given ordered filePriority patterns.\n * Lower index \u2192 higher priority. Unmatched files get score = pattern count.\n *\n * @param path          - Workspace-relative path.\n * @param filePriority  - Ordered priority glob patterns.\n * @returns Numeric priority score.\n */\nfunction getPriorityScore(path: string, filePriority: string[]): number {\n  for (let i = 0; i < filePriority.length; i++) {\n    if (matchesAnyPattern(path, [filePriority[i]])) {\n      return i;\n    }\n  }\n  return filePriority.length; // Lowest priority.\n}\n\n/**\n * Compute a heuristic priority score for a file path.\n *\n * @param path       - Workspace-relative path.\n * @param contextSet - Set of contextFiles paths.\n * @returns Numeric score (lower = higher priority).\n */\nfunction heuristicScore(path: string, contextSet: Set<string>): number {\n  if (contextSet.has(path)) {\n    return 0; // Highest priority.\n  }\n  // src/ or lib/ direct children (e.g. \"src/app.ts\" has 1 slash after the dir).\n  const parts = path.split(\"/\");\n  const inRoot = (parts[0] === \"src\" || parts[0] === \"lib\") && parts.length === 2;\n  if (inRoot) {\n    return 1;\n  }\n  // Other src/lib subdirectory files.\n  if (parts[0] === \"src\" || parts[0] === \"lib\") {\n    return 2;\n  }\n  return 3; // Everything else.\n}\n\n// ---------------------------------------------------------------------------\n// Previous diagram & context file readers\n// ---------------------------------------------------------------------------\n\n/**\n * Read the current `docs/architecture.txt` content as the \"previous version.\"\n * Returns an empty string if the file doesn't exist.\n *\n * @param config        - Active config (for `outputPaths.architecture`).\n * @param workspaceRoot - Workspace root URI.\n * @returns Previous diagram content, or empty string.\n */\nasync function readPreviousArchitecture(config: AsciiAgentConfig, workspaceRoot: vscode.Uri): Promise<string> {\n  try {\n    const archUri = vscode.Uri.joinPath(workspaceRoot, config.outputPaths.architecture);\n    const bytes = await vscode.workspace.fs.readFile(archUri);\n    const raw = Buffer.from(bytes).toString(\"utf-8\");\n    // The file is stored as a markdown document with a heading and code fence.\n    // Strip the wrapper before sending raw ASCII to the LM \u2014 the LM should\n    // receive only the diagram content, not the markdown scaffolding.\n    return stripMarkdownCodeBlock(raw);\n  } catch {\n    return \"\";\n  }\n}\n\n/**\n * Strip a markdown heading and surrounding code fence from a diagram .md file,\n * returning the raw ASCII content within.\n *\n * Handles files in the form:\n *   # <any heading>\\n\\n```\\n<diagram>\\n```\\n\n *\n * If the file does not match that structure (e.g. legacy .txt content or empty),\n * the original string is returned unchanged so the LM still gets usable context.\n *\n * @param content - Full file content of a diagram markdown file.\n * @returns Raw ASCII diagram string, or the original content if no fence found.\n */\nfunction stripMarkdownCodeBlock(content: string): string {\n  // Match optional heading, optional blank line, opening fence, content, closing fence.\n  const match = content.match(/^(?:#[^\\n]*\\n+)?```[^\\n]*\\n([\\s\\S]*?)```\\s*$/m);\n  return match ? match[1].trimEnd() : content;\n}\n\n/**\n * Read all files listed in `config.contextFiles` and concatenate their contents.\n *\n * @param config        - Active config.\n * @param workspaceRoot - Workspace root URI.\n * @returns Concatenated context, or empty string if no files specified.\n */\nasync function readContextFiles(config: AsciiAgentConfig, workspaceRoot: vscode.Uri): Promise<string> {\n  if (config.contextFiles.length === 0) {\n    return \"\";\n  }\n\n  const parts: string[] = [];\n  for (const relPath of config.contextFiles) {\n    try {\n      const fileUri = vscode.Uri.joinPath(workspaceRoot, relPath);\n      const bytes = await vscode.workspace.fs.readFile(fileUri);\n      parts.push(`// Context file: ${relPath}\\n${Buffer.from(bytes).toString(\"utf-8\")}`);\n    } catch {\n      log.warn(`Could not read context file: ${relPath}`);\n    }\n  }\n  return parts.join(\"\\n---\\n\");\n}\n\n// ---------------------------------------------------------------------------\n// Response post-processing\n// ---------------------------------------------------------------------------\n\n/**\n * Clean the raw LM response to extract only the ASCII diagram.\n *\n * Per PRD \u00A719 (model produces markdown-fenced or preamble text mitigation):\n * - Strip ``` code fences.\n * - Strip any lines before the first `+` or `|` character (diagram start indicators).\n * - Strip any lines after the last `+` or `|` that completes the diagram.\n *\n * @param raw - Raw text response from the LM.\n * @returns Cleaned ASCII diagram string.\n */\nfunction postProcessResponse(raw: string): string {\n  // 1. Remove markdown code fences (``` or ```ascii, etc.)\n  let cleaned = raw.replace(/^```[a-z]*\\n?/gm, \"\").replace(/^```\\n?/gm, \"\");\n\n  // 2. Split into lines for boundary detection.\n  const lines = cleaned.split(\"\\n\");\n\n  // Find the first line that looks like it's part of an ASCII diagram.\n  // Indicators: lines starting with `+`, `|`, or containing `---`.\n  const firstDiagramLine = lines.findIndex((line) => /^[+|]/.test(line.trim()) || /^[-+]{3,}/.test(line.trim()));\n\n  // Find the last such line.\n  let lastDiagramLine = -1;\n  for (let i = lines.length - 1; i >= 0; i--) {\n    if (/^[+|]/.test(lines[i].trim()) || /^[-+]{3,}/.test(lines[i].trim())) {\n      lastDiagramLine = i;\n      break;\n    }\n  }\n\n  // If we found diagram boundaries, trim to them. Otherwise return as-is.\n  if (firstDiagramLine !== -1 && lastDiagramLine !== -1 && firstDiagramLine <= lastDiagramLine) {\n    cleaned = lines.slice(firstDiagramLine, lastDiagramLine + 1).join(\"\\n\");\n  }\n\n  return cleaned.trim() + \"\\n\";\n}\n\n// ---------------------------------------------------------------------------\n// Token counting helper\n// ---------------------------------------------------------------------------\n\n/**\n * Safely call `model.countTokens()`. Falls back to character-count heuristic on error.\n *\n * @param model - LM model with `countTokens` support.\n * @param text  - Text to measure.\n * @returns Estimated token count.\n */\nasync function safeCountTokens(model: vscode.LanguageModelChat, text: string): Promise<number> {\n  try {\n    // countTokens accepts a string or a LanguageModelChatMessage array.\n    const count = await model.countTokens(text);\n    return count;\n  } catch {\n    // Fallback: rough estimate of 4 chars per token.\n    return Math.ceil(text.length / 4);\n  }\n}\n", "/**\n * @file lm-client.ts\n * @description Thin, reusable wrapper around `vscode.lm`.\n *\n * Responsibilities (PRD \u00A75.6):\n * - Model selection: `vscode.lm.selectChatModels({ vendor: 'copilot' })`, cache reference.\n * - Request execution: send via `model.sendRequest()`, stream response, return full text.\n * - Cancellation: `CancellationTokenSource` per request; expose `cancelAll()`.\n * - Error handling: quota cooldown, consent prompt, one retry on unknown errors.\n * - Rate limiting: only ONE LM request in-flight at a time (last-write-wins cancellation).\n */\n\nimport * as vscode from \"vscode\";\nimport type { LmClient } from \"./types\";\nimport { log } from \"./logger\";\n\n// ---------------------------------------------------------------------------\n// Constants\n// ---------------------------------------------------------------------------\n\n/** Duration of the quota-exceeded cooldown period in milliseconds. */\nconst QUOTA_COOLDOWN_MS = 60_000;\n\n/** Delay before the single retry attempt on unknown errors, in milliseconds. */\nconst RETRY_DELAY_MS = 3_000;\n\n// ---------------------------------------------------------------------------\n// Factory\n// ---------------------------------------------------------------------------\n\n/**\n * Create a new `LmClient` instance.\n *\n * The returned client manages its own model reference and in-flight request state.\n * Callers should call `dispose()` when done (e.g. after `deactivate()`).\n *\n * @returns A fully initialized `LmClient`.\n */\nexport function createLmClient(): LmClient {\n  /** Cached chat model. Re-selected whenever `vscode.lm.onDidChangeChatModels` fires. */\n  let cachedModel: vscode.LanguageModelChat | undefined;\n\n  /** Whether we are currently in a quota-exceeded cooldown period. */\n  let quotaCooldown = false;\n\n  /** Timeout handle for clearing the cooldown flag. */\n  let cooldownTimer: ReturnType<typeof setTimeout> | undefined;\n\n  /**\n   * `CancellationTokenSource` for the currently in-flight request.\n   * Cancelled (and replaced) when a new request arrives (last-write-wins).\n   */\n  let currentRequestCts: vscode.CancellationTokenSource | undefined;\n\n  /** Disposable for the model-change listener. */\n  let modelChangeDisposable: vscode.Disposable | undefined;\n\n  // -------------------------------------------------------------------------\n  // Model selection\n  // -------------------------------------------------------------------------\n\n  /**\n   * Select and cache the best available Copilot model.\n   * Tries to find a model with vendor 'copilot'. Falls back to first available if needed.\n   *\n   * @returns The selected model, or `undefined` if none available.\n   */\n  async function selectModel(): Promise<vscode.LanguageModelChat | undefined> {\n    try {\n      const models = await vscode.lm.selectChatModels({ vendor: \"copilot\" });\n      if (models.length > 0) {\n        cachedModel = models[0];\n        log.info(`LM model selected: ${cachedModel.name} (vendor: ${cachedModel.vendor})`);\n        return cachedModel;\n      }\n    } catch (err) {\n      log.warn(`Model selection failed: ${String(err)}`);\n    }\n    cachedModel = undefined;\n    return undefined;\n  }\n\n  // Eagerly select a model when the client is created.\n  // Store the promise so isAvailable() can await it instead of checking\n  // a potentially-still-undefined cachedModel synchronously.\n  let initialSelectionPromise: Promise<vscode.LanguageModelChat | undefined> = selectModel();\n\n  // Re-select when available models change (e.g. user signs in/out of Copilot).\n  modelChangeDisposable = vscode.lm.onDidChangeChatModels(() => {\n    log.info(\"LM models changed \u2014 re-selecting.\");\n    initialSelectionPromise = selectModel();\n  });\n\n  // -------------------------------------------------------------------------\n  // Public interface implementation\n  // -------------------------------------------------------------------------\n\n  /**\n   * Send a chat prompt and return the full streamed response text.\n   *\n   * Implements last-write-wins: if a request is already in-flight when this is\n   * called, the old request is cancelled before the new one starts.\n   *\n   * @param messages - Ordered chat messages forming the prompt.\n   * @param token    - Optional external cancellation token.\n   * @returns Full response text as a string.\n   */\n  async function sendPrompt(\n    messages: vscode.LanguageModelChatMessage[],\n    token?: vscode.CancellationToken,\n  ): Promise<string> {\n    // Enforce quota cooldown \u2014 do not attempt requests during cooldown.\n    if (quotaCooldown) {\n      log.warn(\"LM quota cooldown active \u2014 skipping request.\");\n      throw new Error(\"ASCII Agent: LM quota cooldown active. Skipping request.\");\n    }\n\n    // Ensure a model is available.\n    const model = cachedModel ?? (await selectModel());\n    if (!model) {\n      throw new Error(\"ASCII Agent: No Copilot LM model available.\");\n    }\n\n    // Last-write-wins: cancel any in-flight request.\n    if (currentRequestCts) {\n      currentRequestCts.cancel();\n      currentRequestCts.dispose();\n      currentRequestCts = undefined;\n    }\n\n    // Create a new cancellation token for this request.\n    // Merge with any externally provided token.\n    const cts = new vscode.CancellationTokenSource();\n    currentRequestCts = cts;\n\n    // If an external token is provided, propagate its cancellation.\n    let externalCancelDisposable: vscode.Disposable | undefined;\n    if (token) {\n      externalCancelDisposable = token.onCancellationRequested(() => cts.cancel());\n    }\n\n    try {\n      return await executeRequest(model, messages, cts.token);\n    } finally {\n      externalCancelDisposable?.dispose();\n      if (currentRequestCts === cts) {\n        currentRequestCts = undefined;\n      }\n      cts.dispose();\n    }\n  }\n\n  /**\n   * Execute the LM request with one retry on unknown errors.\n   *\n   * @param model    - The selected LM model.\n   * @param messages - Chat messages to send.\n   * @param token    - Cancellation token for this specific request.\n   * @returns Full response text.\n   */\n  async function executeRequest(\n    model: vscode.LanguageModelChat,\n    messages: vscode.LanguageModelChatMessage[],\n    token: vscode.CancellationToken,\n  ): Promise<string> {\n    for (let attempt = 0; attempt < 2; attempt++) {\n      try {\n        const response = await model.sendRequest(messages, {}, token);\n\n        // Stream the response and accumulate into a string.\n        let fullText = \"\";\n        for await (const chunk of response.text) {\n          if (token.isCancellationRequested) {\n            return fullText; // Return whatever we have so far.\n          }\n          fullText += chunk;\n        }\n        return fullText;\n      } catch (err) {\n        if (err instanceof vscode.LanguageModelError) {\n          return await handleLanguageModelError(err, attempt);\n        }\n\n        // Unknown/network error \u2014 retry once after a delay.\n        if (attempt === 0) {\n          log.warn(`LM request failed (attempt ${attempt + 1}): ${String(err)}. Retrying in ${RETRY_DELAY_MS}ms...`);\n          await sleep(RETRY_DELAY_MS);\n          continue; // Retry.\n        }\n\n        // Second attempt also failed \u2014 give up.\n        log.warn(`LM request failed after retry: ${String(err)}`);\n        throw err;\n      }\n    }\n\n    // Should never reach here; TypeScript requires return.\n    throw new Error(\"ASCII Agent: Unexpected end of executeRequest loop.\");\n  }\n\n  /**\n   * Handle a `vscode.LanguageModelError` according to PRD \u00A75.6 rules.\n   *\n   * @param err     - The language model error.\n   * @param attempt - Current attempt index (0-based).\n   * @returns Never returns normally \u2014 always throws.\n   */\n  async function handleLanguageModelError(err: vscode.LanguageModelError, attempt: number): Promise<never> {\n    const msg = err.message.toLowerCase();\n\n    // Quota exceeded \u2014 enter cooldown, do not retry.\n    if (msg.includes(\"quota\") || msg.includes(\"rate limit\") || err.code === \"quota-exceeded\") {\n      quotaCooldown = true;\n      log.warn(`LM quota exceeded. Cooldown for ${QUOTA_COOLDOWN_MS / 1000}s.`);\n      cooldownTimer = setTimeout(() => {\n        quotaCooldown = false;\n        log.info(\"LM quota cooldown expired.\");\n      }, QUOTA_COOLDOWN_MS);\n      throw err; // Do not retry.\n    }\n\n    // Consent not given \u2014 show one-time info message.\n    if (msg.includes(\"consent\") || msg.includes(\"not authorized\") || err.code === \"no-permissions\") {\n      log.warn(\"Copilot consent not given. Prompting user.\");\n      vscode.window.showInformationMessage(\n        \"ASCII Agent: Please authorize GitHub Copilot to enable architecture diagram generation.\",\n      );\n      throw err; // Do not retry.\n    }\n\n    // Generic LM error \u2014 retry once with delay.\n    if (attempt === 0) {\n      log.warn(`LM error (attempt ${attempt + 1}): ${String(err)}. Retrying in ${RETRY_DELAY_MS / 1000}s...`);\n      await sleep(RETRY_DELAY_MS);\n      // Caller's loop will retry; throw to break out of sendRequest and trigger the retry.\n      throw err;\n    }\n\n    log.error(`LM error after retry: ${String(err)}`);\n    throw err;\n  }\n\n  /**\n   * Cancel all currently in-flight LM requests.\n   * Called during extension `deactivate()`.\n   */\n  function cancelAll(): void {\n    if (currentRequestCts) {\n      currentRequestCts.cancel();\n      currentRequestCts.dispose();\n      currentRequestCts = undefined;\n    }\n  }\n\n  /**\n   * Returns `true` if a Copilot model is currently available and no cooldown is active.\n   *\n   * Awaits the initial model selection promise to avoid a race condition where\n   * `createLmClient()` is called and `isAvailable()` is checked before the\n   * async `selectModel()` call has resolved.\n   */\n  async function isAvailable(): Promise<boolean> {\n    // If no model is cached yet, wait for the initial selection to complete.\n    if (cachedModel === undefined) {\n      await initialSelectionPromise;\n    }\n    return cachedModel !== undefined && !quotaCooldown;\n  }\n\n  /**\n   * Release all resources held by this client instance.\n   */\n  function dispose(): void {\n    cancelAll();\n    modelChangeDisposable?.dispose();\n    if (cooldownTimer !== undefined) {\n      clearTimeout(cooldownTimer);\n    }\n  }\n\n  return { sendPrompt, cancelAll, isAvailable, dispose };\n}\n\n// ---------------------------------------------------------------------------\n// Helpers (private)\n// ---------------------------------------------------------------------------\n\n/**\n * Promisified sleep for retry delays.\n *\n * @param ms - Duration to wait in milliseconds.\n */\nfunction sleep(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n", "/**\n * @file history.ts\n * @description Versioning engine for `docs/architecture.txt`.\n *\n * Before every architecture overwrite, a timestamped snapshot is saved to\n * `.ascii_history/` inside the workspace root. Old snapshots are pruned when\n * the count exceeds `maxHistorySnapshots`.\n *\n * IMPORTANT: Only `architecture.txt` is versioned. `file_tree.txt` is\n * deterministic and can be regenerated instantly, so versioning it is wasteful.\n *\n * See PRD \u00A75.7.\n */\n\nimport * as vscode from \"vscode\";\n\n/** Directory name for storing history snapshots, relative to workspace root. */\nconst HISTORY_DIR = \".ascii_history\";\n\n// ---------------------------------------------------------------------------\n// Public API\n// ---------------------------------------------------------------------------\n\n/**\n * Save a timestamped snapshot of the current architecture content to `.ascii_history/`.\n *\n * File naming: `architecture_<ISO8601_timestamp>.txt`\n * Example:     `architecture_2026-02-19T14-30-00-000Z.txt`\n *\n * After saving, prune old snapshots if the count exceeds `maxHistorySnapshots`.\n *\n * @param workspaceRoot  - Absolute URI of the workspace root.\n * @param currentContent - The current contents of `docs/architecture.txt` to snapshot.\n */\nexport async function saveSnapshot(workspaceRoot: vscode.Uri, currentContent: string): Promise<void> {\n  const historyDirUri = vscode.Uri.joinPath(workspaceRoot, HISTORY_DIR);\n\n  // Ensure the history directory exists.\n  try {\n    await vscode.workspace.fs.createDirectory(historyDirUri);\n  } catch {\n    // Already exists or not creatable \u2014 a subsequent write error will surface it.\n  }\n\n  // Build a filename-safe ISO 8601 timestamp (colons replaced with dashes).\n  const timestamp = new Date().toISOString().replace(/:/g, \"-\");\n  const fileName = `architecture_${timestamp}.txt`;\n  const snapshotUri = vscode.Uri.joinPath(historyDirUri, fileName);\n\n  // Write the snapshot.\n  await vscode.workspace.fs.writeFile(snapshotUri, Buffer.from(currentContent, \"utf-8\"));\n}\n\n/**\n * Prune old snapshots so that the history directory contains at most\n * `maxSnapshots - 1` files after pruning (leaving room for the new one being saved).\n *\n * Oldest snapshots (by file modification time) are deleted first.\n *\n * @param workspaceRoot - Absolute URI of the workspace root.\n * @param maxSnapshots  - Maximum number of snapshots to retain.\n */\nexport async function pruneSnapshots(workspaceRoot: vscode.Uri, maxSnapshots: number): Promise<void> {\n  const historyDirUri = vscode.Uri.joinPath(workspaceRoot, HISTORY_DIR);\n\n  let entries: [string, vscode.FileType][];\n  try {\n    entries = await vscode.workspace.fs.readDirectory(historyDirUri);\n  } catch {\n    // Directory doesn't exist yet \u2014 nothing to prune.\n    return;\n  }\n\n  // Filter to only `.txt` snapshot files.\n  const snapshotNames = entries\n    .filter(([name, type]) => type === vscode.FileType.File && name.endsWith(\".txt\"))\n    .map(([name]) => name);\n\n  if (snapshotNames.length <= maxSnapshots) {\n    return;\n  }\n\n  // Gather modification times for sorting.\n  const withMtimes: { name: string; mtime: number }[] = [];\n  for (const name of snapshotNames) {\n    try {\n      const stat = await vscode.workspace.fs.stat(vscode.Uri.joinPath(historyDirUri, name));\n      withMtimes.push({ name, mtime: stat.mtime });\n    } catch {\n      // If we can't stat a file, include it with mtime=0 (will be deleted first).\n      withMtimes.push({ name, mtime: 0 });\n    }\n  }\n\n  // Sort ascending: oldest first.\n  withMtimes.sort((a, b) => a.mtime - b.mtime);\n\n  // Delete oldest files until count equals maxSnapshots - 1.\n  const targetCount = maxSnapshots - 1;\n  const toDelete = withMtimes.slice(0, withMtimes.length - targetCount);\n\n  for (const { name } of toDelete) {\n    try {\n      await vscode.workspace.fs.delete(vscode.Uri.joinPath(historyDirUri, name));\n    } catch {\n      // Best-effort deletion \u2014 ignore errors.\n    }\n  }\n}\n", "/**\n * @file extension.ts\n * @description VS Code extension entry point for ASCII Agent.\n *\n * Responsibilities:\n * - `activate()`: Load config, register commands, start watcher (if enabled), show status bar.\n * - `deactivate()`: Dispose watchers, cancel in-flight LM requests.\n *\n * NOTE: This file is intentionally project-agnostic. Zero hardcoded paths or project names.\n * All workspace resolution is done via `vscode.workspace.workspaceFolders[0].uri`.\n */\n\nimport * as vscode from \"vscode\";\nimport { loadConfig, watchConfigFile } from \"./config\";\nimport { initLogger, log } from \"./logger\";\nimport { resetSessionTokens, recordTokenUsage, getSessionTokenUsage, getLifetimeTokenUsage } from \"./token-tracker\";\nimport type { AsciiAgentConfig, ArchitectureGenerationResult } from \"./types\";\nimport { WatcherState } from \"./types\";\n\n// ---------------------------------------------------------------------------\n// Extension-level mutable state\n// ---------------------------------------------------------------------------\n\n/** The currently active config (hot-reloadable). */\nlet currentConfig: AsciiAgentConfig;\n\n/** Current watcher state, toggleable via command. */\nlet watcherState: WatcherState = WatcherState.Disabled;\n\n/** Status bar item showing watcher state. */\nlet statusBarItem: vscode.StatusBarItem;\n\n/** Disposable for the currently running watcher session (set in Phase 6). */\nlet watcherSessionDisposable: vscode.Disposable | undefined;\n\n/**\n * Extension context stored at activation time.\n * Used for token usage tracking (globalState) and welcome-prompt state.\n */\nlet extensionContext: vscode.ExtensionContext;\n\n// ---------------------------------------------------------------------------\n// Workspace root helpers\n// ---------------------------------------------------------------------------\n\n/**\n * Resolve the active workspace root at call time.\n *\n * Always read `workspaceFolders` fresh rather than relying on a closure captured\n * at activation, so commands target the correct folder regardless of which window\n * is focused or whether the workspace changed after the extension activated.\n *\n * Exported for unit testing.\n *\n * @returns The URI of the first workspace folder, or `undefined` if none is open.\n */\nexport function resolveWorkspaceRoot(): vscode.Uri | undefined {\n  return vscode.workspace.workspaceFolders?.[0]?.uri;\n}\n\n/**\n * Show a warning when a command is invoked with no open workspace folder.\n */\nfunction warnNoWorkspace(): void {\n  vscode.window.showWarningMessage(\"ASCII Agent: No workspace folder is open.\");\n  log.warn(\"Command invoked with no open workspace folder.\");\n}\n\n// ---------------------------------------------------------------------------\n// Activate\n// ---------------------------------------------------------------------------\n\n/**\n * Extension activation entry point.\n * Called by VS Code when any `activationEvent` is triggered.\n *\n * @param context - The extension context provided by VS Code.\n */\nexport async function activate(context: vscode.ExtensionContext): Promise<void> {\n  // Create the output channel FIRST so all subsequent code can log (PRD \u00A717).\n  const channel = vscode.window.createOutputChannel(\"ASCII Agent\");\n  context.subscriptions.push(channel);\n  initLogger(channel);\n\n  // Store context for token tracking and first-install detection.\n  extensionContext = context;\n  await resetSessionTokens(context);\n\n  // --- Guard: require at least one workspace folder (PRD \u00A77.2) ---\n  if (!vscode.workspace.workspaceFolders || vscode.workspace.workspaceFolders.length === 0) {\n    log.warn(\"No workspace folder open \u2014 aborting activation.\");\n    return;\n  }\n\n  // Warn about multi-root workspaces \u2014 only first root is monitored (PRD \u00A77.3).\n  if (vscode.workspace.workspaceFolders.length > 1) {\n    log.warn(\"Multiple workspace folders detected. Only the first folder will be monitored.\");\n    vscode.window.showWarningMessage(\"ASCII Agent only monitors the first workspace folder.\");\n  }\n\n  const workspaceRoot = vscode.workspace.workspaceFolders[0].uri;\n\n  // --- Load initial config ---\n  currentConfig = await loadConfig(workspaceRoot);\n  log.info(`Config loaded. debounceMs=${currentConfig.debounceMs}, autoWatch=${currentConfig.autoWatchEnabled}`);\n\n  // --- Hot-reload config on .asciirc.json changes ---\n  const configWatcherDisposable = watchConfigFile(workspaceRoot, (newCfg) => {\n    currentConfig = newCfg;\n    log.info(\"Config reloaded from .asciirc.json.\");\n    // If the watcher is running, restart it with the new config.\n    if (watcherState === WatcherState.Active) {\n      stopWatcher();\n      startWatcher(context, workspaceRoot);\n    }\n  });\n  context.subscriptions.push(configWatcherDisposable);\n\n  // --- Status bar ---\n  statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 100);\n  statusBarItem.command = \"asciiAgent.toggleAutoWatch\";\n  updateStatusBar(WatcherState.Disabled);\n  statusBarItem.show();\n  context.subscriptions.push(statusBarItem);\n\n  // --- Register commands ---\n  // Commands resolve the active workspace root at invocation time (not from the\n  // activation-time closure) so they always target the correct folder even when\n  // multiple windows are open or the workspace changes after activation.\n  context.subscriptions.push(\n    vscode.commands.registerCommand(\"asciiAgent.initialize\", () => {\n      const root = resolveWorkspaceRoot();\n      return root ? commandInitialize(root) : warnNoWorkspace();\n    }),\n    vscode.commands.registerCommand(\"asciiAgent.generateNow\", () => {\n      const root = resolveWorkspaceRoot();\n      return root ? commandGenerateNow(root) : warnNoWorkspace();\n    }),\n    vscode.commands.registerCommand(\"asciiAgent.toggleAutoWatch\", () => {\n      const root = resolveWorkspaceRoot();\n      return root ? commandToggleAutoWatch(context, root) : warnNoWorkspace();\n    }),\n    vscode.commands.registerCommand(\"asciiAgent.showTokenUsage\", () => commandShowTokenUsage(context)),\n  );\n\n  // --- Auto-start watcher if configured ---\n  if (currentConfig.autoWatchEnabled) {\n    startWatcher(context, workspaceRoot); // Use activation-time root for the watcher \u2014 correct for this window.\n  }\n\n  // --- Activation success message (fades after 3 seconds) ---\n  const msg = vscode.window.setStatusBarMessage(\"ASCII Agent: active\", 3000);\n  context.subscriptions.push(msg);\n\n  // --- First-install welcome prompt ---\n  await maybeShowWelcomePrompt(context, workspaceRoot);\n\n  log.info(\"Activated successfully.\");\n}\n\n// ---------------------------------------------------------------------------\n// Deactivate\n// ---------------------------------------------------------------------------\n\n/**\n * Extension deactivation entry point.\n * Called by VS Code when the extension is deactivated or VS Code is closed.\n * Dispose all watchers and cancel in-flight LM requests.\n */\nexport function deactivate(): void {\n  stopWatcher();\n  log.info(\"Deactivated.\");\n}\n\n// ---------------------------------------------------------------------------\n// Command: Initialize\n// ---------------------------------------------------------------------------\n\n/**\n * Command handler for `asciiAgent.initialize`.\n *\n * Creates the `docs/` directory if missing, writes a default `.asciirc.json` if missing,\n * runs both generators once immediately, and prompts about `.gitignore`.\n *\n * @param workspaceRoot - The URI of the workspace root folder.\n */\nasync function commandInitialize(workspaceRoot: vscode.Uri): Promise<void> {\n  log.info(\"Running: asciiAgent.initialize\");\n\n  const { generateFileTree } = await import(\"./tree-generator\");\n  const { ensureDirectoryExists } = await import(\"./utils\");\n\n  // 1. Ensure the configured output directory exists (PRD \u00A77.4).\n  const outputDir = currentConfig.outputPaths.fileTree.split(\"/\").slice(0, -1).join(\"/\");\n  await ensureDirectoryExists(vscode.Uri.joinPath(workspaceRoot, outputDir || \"docs\"));\n\n  // 2. Create default .asciirc.json if absent.\n  await maybeCreateDefaultAsciirc(workspaceRoot);\n\n  // Reload config after potential creation.\n  currentConfig = await loadConfig(workspaceRoot);\n\n  // 3. Check for existing output files and confirm overwrite if any exist.\n  const existingFiles = await detectExistingOutputFiles(workspaceRoot, currentConfig);\n  if (existingFiles.length > 0) {\n    const fileList = existingFiles.map((f) => `\u2022 ${f}`).join(\"\\n\");\n    const choice = await vscode.window.showWarningMessage(\n      `ASCII Agent: The following files already exist:\\n\\n${fileList}\\n\\nOverwrite them?`,\n      { modal: true },\n      \"Overwrite\",\n    );\n    if (choice !== \"Overwrite\") {\n      log.info(\"Initialize cancelled by user \u2014 existing files would be overwritten.\");\n      return;\n    }\n  }\n\n  // 4. Generate and write file tree.\n  await safeGenerateAndWriteFileTree(workspaceRoot, generateFileTree);\n\n  // 5. Generate and write architecture diagram (with progress notification).\n  let archGenerated = false;\n  await vscode.window.withProgress(\n    {\n      location: vscode.ProgressLocation.Notification,\n      title: \"ASCII Agent\",\n      cancellable: true,\n    },\n    async (progress, archToken) => {\n      archGenerated = await safeGenerateArchitecture(workspaceRoot, progress, archToken);\n    },\n  );\n  if (!archGenerated) {\n    vscode.window.showWarningMessage(\n      'ASCII Agent: File tree created. Architecture diagram skipped \u2014 Copilot not available yet. Run \"ASCII Agent: Generate Now\" once Copilot is ready.',\n    );\n  }\n\n  // 6. Prompt about .gitignore (PRD \u00A77.7).\n  await promptGitignoreUpdate(workspaceRoot);\n\n  vscode.window.showInformationMessage(\"ASCII Agent: Initialization complete.\");\n  log.info(\"Initialization complete.\");\n}\n\n// ---------------------------------------------------------------------------\n// Command: Generate Now\n// ---------------------------------------------------------------------------\n\n/**\n * Command handler for `asciiAgent.generateNow`.\n *\n * Manually triggers both generators with a cancellable progress notification.\n *\n * @param workspaceRoot - The URI of the workspace root folder.\n */\nasync function commandGenerateNow(workspaceRoot: vscode.Uri): Promise<void> {\n  log.info(\"Running: asciiAgent.generateNow\");\n\n  await vscode.window.withProgress(\n    {\n      location: vscode.ProgressLocation.Notification,\n      title: \"ASCII Agent\",\n      cancellable: true,\n    },\n    async (progress, token) => {\n      // Cancel any pending debounced ops before starting (PRD \u00A77.5).\n      import(\"./watcher\").then(({ cancelPendingTimers }) => cancelPendingTimers()).catch(() => undefined); // Safe no-op if watcher not yet loaded.\n\n      progress.report({ message: \"Generating file tree...\" });\n      setStatusBarGenerating(true);\n\n      try {\n        const { generateFileTree } = await import(\"./tree-generator\");\n        const { ensureDirectoryExists } = await import(\"./utils\");\n\n        if (token.isCancellationRequested) {\n          return;\n        }\n\n        // Ensure output directory exists (PRD \u00A77.4).\n        const outputDir = currentConfig.outputPaths.fileTree.split(\"/\").slice(0, -1).join(\"/\");\n        await ensureDirectoryExists(vscode.Uri.joinPath(workspaceRoot, outputDir || \"docs\"));\n\n        // --- File tree generation ---\n        const treeStart = Date.now();\n        const treeContent = await generateFileTree(workspaceRoot, currentConfig);\n        await writeOutputFile(workspaceRoot, currentConfig.outputPaths.fileTree, treeContent);\n        log.info(`File tree generated in ${Date.now() - treeStart}ms.`);\n\n        if (token.isCancellationRequested) {\n          return;\n        }\n\n        progress.report({ message: \"Generating architecture diagram (AI)...\" });\n\n        // --- Architecture diagram generation ---\n        const { generateArchitectureDiagram } = await import(\"./architecture-agent\");\n        const { createLmClient } = await import(\"./lm-client\");\n        const lmClient = createLmClient();\n\n        try {\n          if (!(await lmClient.isAvailable())) {\n            vscode.window.showWarningMessage(\n              \"ASCII Agent: Copilot model not available \u2014 only file tree was regenerated.\",\n            );\n            log.warn(\"LM unavailable \u2014 skipping architecture generation.\");\n            return;\n          }\n\n          const archStart = Date.now();\n          const archResult = await generateArchitectureDiagram(currentConfig, workspaceRoot, lmClient, token);\n\n          if (token.isCancellationRequested) {\n            return;\n          }\n\n          // Snapshot before overwriting (PRD \u00A75.7).\n          const { saveSnapshot } = await import(\"./history\");\n          await saveSnapshot(workspaceRoot, archResult.diagram);\n          await pruneHistory(workspaceRoot);\n\n          await writeOutputFile(workspaceRoot, currentConfig.outputPaths.architecture, archResult.diagram);\n          await recordTokenUsage(extensionContext, archResult.inputTokensEstimate, archResult.outputTokensEstimate);\n          log.info(`Architecture diagram generated in ${Date.now() - archStart}ms.`);\n          vscode.window.showInformationMessage(\"ASCII Agent: Diagrams updated.\");\n        } finally {\n          lmClient.dispose();\n        }\n      } finally {\n        setStatusBarGenerating(false);\n      }\n    },\n  );\n}\n\n// ---------------------------------------------------------------------------\n// Command: Toggle Auto-Watch\n// ---------------------------------------------------------------------------\n\n/**\n * Command handler for `asciiAgent.toggleAutoWatch`.\n *\n * Toggles the watcher between active and paused.\n * The toggle does NOT persist to `.asciirc.json` \u2014 it resets on VS Code reload.\n *\n * @param context       - Extension context, needed to re-register the watcher.\n * @param workspaceRoot - URI of the workspace root.\n */\nfunction commandToggleAutoWatch(context: vscode.ExtensionContext, workspaceRoot: vscode.Uri): void {\n  if (watcherState === WatcherState.Active) {\n    stopWatcher();\n    vscode.window.showInformationMessage(\"ASCII Agent: Auto-watch is now OFF.\");\n    log.info(\"Auto-watch paused by user.\");\n  } else {\n    startWatcher(context, workspaceRoot);\n    vscode.window.showInformationMessage(\"ASCII Agent: Auto-watch is now ON.\");\n    log.info(\"Auto-watch started by user.\");\n  }\n}\n\n// ---------------------------------------------------------------------------\n// Command: Show Token Usage\n// ---------------------------------------------------------------------------\n\n/**\n * Command handler for `asciiAgent.showTokenUsage`.\n *\n * Displays a read-only Quick Pick panel summarising current session and lifetime\n * token usage estimates. Section headings use `QuickPickItemKind.Separator` so they\n * render as non-selectable dividers. The panel closes on any item selection or\n * on focus loss.\n *\n * Estimates are derived via a ~4 chars/token heuristic; they are for rough cost\n * awareness only, not billing accuracy.\n *\n * @param context - Extension context providing `globalState` for token tallies.\n */\nfunction commandShowTokenUsage(context: vscode.ExtensionContext): void {\n  const session = getSessionTokenUsage(context);\n  const lifetime = getLifetimeTokenUsage(context);\n\n  /** Format a number with locale-aware thousands separators. */\n  const fmt = (n: number): string => n.toLocaleString();\n\n  const sessionTotal = session.inputTokensEstimate + session.outputTokensEstimate;\n  const lifetimeTotal = lifetime.inputTokensEstimate + lifetime.outputTokensEstimate;\n  const sessionReqLabel = session.requestCount === 1 ? \"1 request\" : `${fmt(session.requestCount)} requests`;\n  const lifetimeReqLabel = lifetime.requestCount === 1 ? \"1 request\" : `${fmt(lifetime.requestCount)} requests`;\n\n  const quickPick = vscode.window.createQuickPick();\n  quickPick.title = \"ASCII Agent \u2014 Token Usage\";\n  quickPick.placeholder = \"\";\n  quickPick.ignoreFocusOut = false;\n  quickPick.canSelectMany = false;\n\n  quickPick.items = [\n    { label: \"Session (this window)\", kind: vscode.QuickPickItemKind.Separator },\n    {\n      label: `  ~${fmt(sessionTotal)} tokens   (${sessionReqLabel})  \u2014 ~${fmt(session.inputTokensEstimate)} in / ~${fmt(session.outputTokensEstimate)} out`,\n      alwaysShow: true,\n    },\n    { label: \"Lifetime (all time)\", kind: vscode.QuickPickItemKind.Separator },\n    {\n      label: `  ~${fmt(lifetimeTotal)} tokens   (${lifetimeReqLabel}) \u2014 ~${fmt(lifetime.inputTokensEstimate)} in / ~${fmt(lifetime.outputTokensEstimate)} out`,\n      alwaysShow: true,\n    },\n    {\n      label: \"Note: Estimates only \u2014 LM streaming API does not provide exact counts.\",\n      kind: vscode.QuickPickItemKind.Separator,\n    },\n  ];\n\n  // Dismiss on any item selection.\n  quickPick.onDidAccept(() => quickPick.hide());\n  quickPick.onDidHide(() => quickPick.dispose());\n\n  quickPick.show();\n}\n\n// ---------------------------------------------------------------------------\n// Watcher lifecycle helpers\n// ---------------------------------------------------------------------------\n\n/**\n * Start the file-system watcher and register its disposable.\n * Sets `watcherState` to `Active`.\n *\n * @param context       - Extension context for disposable registration.\n * @param workspaceRoot - URI of the workspace root.\n */\nfunction startWatcher(context: vscode.ExtensionContext, workspaceRoot: vscode.Uri): void {\n  import(\"./watcher\").then(({ startWatching }) => {\n    watcherSessionDisposable = startWatching(currentConfig, context, {\n      onTreeRegenNeeded: async () => {\n        const { generateFileTree } = await import(\"./tree-generator\");\n        await safeGenerateAndWriteFileTree(workspaceRoot, generateFileTree);\n      },\n      onArchitectureRegenNeeded: async () => {\n        await safeGenerateArchitecture(workspaceRoot);\n      },\n    });\n    context.subscriptions.push(watcherSessionDisposable);\n    watcherState = WatcherState.Active;\n    updateStatusBar(WatcherState.Active);\n  });\n}\n\n/**\n * Stop the currently active watcher session and update state.\n */\nfunction stopWatcher(): void {\n  watcherSessionDisposable?.dispose();\n  watcherSessionDisposable = undefined;\n  watcherState = WatcherState.Paused;\n  updateStatusBar(WatcherState.Paused);\n}\n\n// ---------------------------------------------------------------------------\n// Status bar helpers\n// ---------------------------------------------------------------------------\n\n/**\n * Update the status bar item to reflect the current watcher state.\n *\n * @param state - The new watcher state.\n */\nfunction updateStatusBar(state: WatcherState): void {\n  if (!statusBarItem) {\n    return;\n  }\n  switch (state) {\n    case WatcherState.Active:\n      statusBarItem.text = \"$(eye) ASCII Agent\";\n      statusBarItem.tooltip = \"ASCII Agent: auto-watch active. Click to pause.\";\n      break;\n    case WatcherState.Paused:\n      statusBarItem.text = \"$(eye-closed) ASCII Agent (paused)\";\n      statusBarItem.tooltip = \"ASCII Agent: auto-watch paused. Click to resume.\";\n      break;\n    case WatcherState.Disabled:\n      statusBarItem.text = \"$(eye) ASCII Agent\";\n      statusBarItem.tooltip = \"ASCII Agent: inactive.\";\n      break;\n  }\n}\n\n/**\n * Update status bar to show \"generating...\" spinner during diagram generation.\n *\n * @param generating - Whether generation is in progress.\n */\nfunction setStatusBarGenerating(generating: boolean): void {\n  if (!statusBarItem) {\n    return;\n  }\n  if (generating) {\n    statusBarItem.text = \"$(sync~spin) ASCII Agent: generating...\";\n  } else {\n    updateStatusBar(watcherState);\n  }\n}\n\n// ---------------------------------------------------------------------------\n// Shared helpers\n// ---------------------------------------------------------------------------\n\n/**\n * Write content to an output file, creating parent directories as needed.\n *\n * @param workspaceRoot  - URI of the workspace root.\n * @param relPath        - Path relative to workspace root (e.g. \"docs/file_tree.txt\").\n * @param content        - String content to write.\n */\nasync function writeOutputFile(workspaceRoot: vscode.Uri, relPath: string, content: string): Promise<void> {\n  const { ensureDirectoryExists } = await import(\"./utils\");\n  const fileUri = vscode.Uri.joinPath(workspaceRoot, relPath);\n  const parentRel = relPath.split(\"/\").slice(0, -1).join(\"/\");\n  if (parentRel) {\n    await ensureDirectoryExists(vscode.Uri.joinPath(workspaceRoot, parentRel));\n  }\n  await vscode.workspace.fs.writeFile(fileUri, Buffer.from(content, \"utf-8\"));\n}\n\n/**\n * Safely generate and write the file tree, logging errors without rethrowing.\n *\n * @param workspaceRoot    - URI of workspace root.\n * @param generateFileTree - The tree-generator function.\n */\nasync function safeGenerateAndWriteFileTree(\n  workspaceRoot: vscode.Uri,\n  generateFileTree: (root: vscode.Uri, cfg: AsciiAgentConfig) => Promise<string>,\n): Promise<void> {\n  try {\n    const content = await generateFileTree(workspaceRoot, currentConfig);\n    await writeOutputFile(workspaceRoot, currentConfig.outputPaths.fileTree, content);\n    log.info(\"File tree written successfully.\");\n  } catch (err) {\n    log.error(`Failed to generate file tree: ${String(err)}`);\n  }\n}\n\n/**\n * Safely generate and write the architecture diagram.\n * Returns `true` if the diagram was generated and written, `false` if the LM\n * was unavailable or generation failed.\n *\n * Accepts an optional `progress` reporter and cancellation token so callers\n * can surface a live elapsed-time notification to the user while the LM streams.\n *\n * @param workspaceRoot - URI of workspace root.\n * @param progress      - Optional VS Code progress reporter for notification messages.\n * @param archToken     - Optional cancellation token from the progress dialog.\n * @returns Whether the diagram was successfully generated.\n */\nasync function safeGenerateArchitecture(\n  workspaceRoot: vscode.Uri,\n  progress?: vscode.Progress<{ message?: string; increment?: number }>,\n  archToken?: vscode.CancellationToken,\n): Promise<boolean> {\n  try {\n    const { generateArchitectureDiagram } = await import(\"./architecture-agent\");\n    const { createLmClient } = await import(\"./lm-client\");\n    const { saveSnapshot } = await import(\"./history\");\n\n    const lmClient = createLmClient();\n    try {\n      if (!(await lmClient.isAvailable())) {\n        log.info(\"LM unavailable \u2014 skipping architecture generation.\");\n        return false;\n      }\n\n      // Start elapsed-time ticker so the user knows progress is happening.\n      const genStart = Date.now();\n      progress?.report({ message: \"Generating architecture diagram (AI)... 0s elapsed\" });\n      const ticker = setInterval(() => {\n        const elapsed = Math.round((Date.now() - genStart) / 1000);\n        progress?.report({ message: `Generating architecture diagram (AI)... ${elapsed}s elapsed` });\n      }, 1000);\n\n      let archResult: ArchitectureGenerationResult | undefined;\n      try {\n        archResult = await generateArchitectureDiagram(currentConfig, workspaceRoot, lmClient, archToken);\n      } finally {\n        clearInterval(ticker);\n      }\n\n      if (archToken?.isCancellationRequested || !archResult) {\n        return false;\n      }\n\n      await saveSnapshot(workspaceRoot, archResult.diagram);\n      await pruneHistory(workspaceRoot);\n      await writeOutputFile(workspaceRoot, currentConfig.outputPaths.architecture, archResult.diagram);\n\n      // Record token usage estimates for this request.\n      await recordTokenUsage(extensionContext, archResult.inputTokensEstimate, archResult.outputTokensEstimate);\n\n      const elapsed = ((Date.now() - genStart) / 1000).toFixed(1);\n      progress?.report({ message: `Architecture diagram complete (${elapsed}s)` });\n      log.info(`Architecture diagram written successfully in ${elapsed}s.`);\n      return true;\n    } finally {\n      lmClient.dispose();\n    }\n  } catch (err) {\n    log.error(`Failed to generate architecture diagram: ${String(err)}`);\n    return false;\n  }\n}\n\n/**\n * Prune old history snapshots to stay within `config.maxHistorySnapshots`.\n *\n * @param workspaceRoot - URI of workspace root.\n */\nasync function pruneHistory(workspaceRoot: vscode.Uri): Promise<void> {\n  try {\n    const { pruneSnapshots } = await import(\"./history\");\n    await pruneSnapshots(workspaceRoot, currentConfig.maxHistorySnapshots);\n  } catch (err) {\n    log.warn(`Snapshot pruning failed: ${String(err)}`);\n  }\n}\n\n/**\n * Check which configured output files already exist in the workspace.\n * Returns an array of workspace-relative paths for files that exist.\n *\n * @param workspaceRoot - URI of workspace root.\n * @param config        - Current extension config (used to resolve configured output paths).\n */\nasync function detectExistingOutputFiles(\n  workspaceRoot: vscode.Uri,\n  config: import(\"./types\").AsciiAgentConfig,\n): Promise<string[]> {\n  const candidates = [config.outputPaths.fileTree, config.outputPaths.architecture];\n  const existing: string[] = [];\n  for (const relPath of candidates) {\n    try {\n      await vscode.workspace.fs.stat(vscode.Uri.joinPath(workspaceRoot, relPath));\n      existing.push(relPath);\n    } catch {\n      // File does not exist \u2014 no action needed.\n    }\n  }\n  return existing;\n}\n\n/**\n * Create a default `.asciirc.json` in the workspace root if one does not exist.\n *\n * @param workspaceRoot - URI of workspace root.\n */\nasync function maybeCreateDefaultAsciirc(workspaceRoot: vscode.Uri): Promise<void> {\n  const configUri = vscode.Uri.joinPath(workspaceRoot, \".asciirc.json\");\n  try {\n    await vscode.workspace.fs.stat(configUri);\n    // File exists \u2014 do nothing.\n  } catch {\n    // File absent \u2014 write defaults.\n    const { getDefaultConfig } = await import(\"./config\");\n    const defaults = getDefaultConfig();\n    const content = JSON.stringify(defaults, null, 2);\n    await vscode.workspace.fs.writeFile(configUri, Buffer.from(content, \"utf-8\"));\n    log.info(\"Created default .asciirc.json.\");\n  }\n}\n\n/**\n * Check whether `.ascii_history/` is in `.gitignore` and prompt the user if not.\n *\n * Per PRD \u00A77.7: do NOT auto-modify; prompt with a yes/no dialog.\n *\n * @param workspaceRoot - URI of workspace root.\n */\nasync function promptGitignoreUpdate(workspaceRoot: vscode.Uri): Promise<void> {\n  const gitignoreUri = vscode.Uri.joinPath(workspaceRoot, \".gitignore\");\n\n  let content: string;\n  try {\n    const bytes = await vscode.workspace.fs.readFile(gitignoreUri);\n    content = Buffer.from(bytes).toString(\"utf-8\");\n  } catch {\n    // .gitignore doesn't exist \u2014 skip.\n    return;\n  }\n\n  // Check if .ascii_history/ is already listed.\n  if (content.includes(\".ascii_history\")) {\n    return;\n  }\n\n  const choice = await vscode.window.showInformationMessage(\n    \"ASCII Agent: Add .ascii_history/ to .gitignore?\",\n    \"Yes\",\n    \"No\",\n  );\n\n  if (choice === \"Yes\") {\n    const appended = content.trimEnd() + \"\\n\\n# ASCII Agent history snapshots\\n.ascii_history/\\n\";\n    await vscode.workspace.fs.writeFile(gitignoreUri, Buffer.from(appended, \"utf-8\"));\n    log.info(\"Added .ascii_history/ to .gitignore.\");\n  }\n}\n\n// ---------------------------------------------------------------------------\n// First-install welcome prompt\n// ---------------------------------------------------------------------------\n\nconst WELCOME_SHOWN_KEY = \"asciiAgent.welcomeShown\";\n\n/**\n * Show a one-time welcome dialog the first time ASCII Agent activates in a\n * workspace. Offers two quick-start actions so the user does not have to look\n * up commands:\n *\n * - **Initialize + Auto-Watch** \u2014 runs `commandInitialize` (creates output files\n *   and starts the file-system watcher for ongoing auto-updates).\n * - **Generate Once** \u2014 runs a single file-tree + architecture generation with no\n *   watcher, useful for one-off snapshots.\n *\n * After the user makes a choice (or dismisses), the flag is saved to `globalState`\n * so the prompt is never shown again for this installation.\n *\n * @param context       - Extension context for `globalState` persistence.\n * @param workspaceRoot - URI of the current workspace root.\n */\nasync function maybeShowWelcomePrompt(context: vscode.ExtensionContext, workspaceRoot: vscode.Uri): Promise<void> {\n  if (context.globalState.get<boolean>(WELCOME_SHOWN_KEY)) {\n    return; // Already shown \u2014 do not show again.\n  }\n\n  // Mark as shown immediately so concurrent activations or crashes do not\n  // cause the prompt to appear twice.\n  await context.globalState.update(WELCOME_SHOWN_KEY, true);\n\n  const INIT_WATCH = \"Initialize + Auto-Watch\";\n  const GEN_ONCE = \"Generate Once (No Watch)\";\n\n  const choice = await vscode.window.showInformationMessage(\n    \"Welcome to ASCII Agent! Generate an ASCII file-tree and a Copilot-powered \" +\n      \"architecture diagram for this workspace. Choose how you'd like to start:\",\n    { modal: true },\n    INIT_WATCH,\n    GEN_ONCE,\n  );\n\n  if (choice === INIT_WATCH) {\n    log.info(\"Welcome prompt: user chose Initialize + Auto-Watch.\");\n    await commandInitialize(workspaceRoot);\n    // Ensure watcher is running even if autoWatchEnabled was false in config.\n    if (watcherState !== WatcherState.Active) {\n      startWatcher(context, workspaceRoot);\n    }\n  } else if (choice === GEN_ONCE) {\n    log.info(\"Welcome prompt: user chose Generate Once.\");\n    const { generateFileTree } = await import(\"./tree-generator\");\n    const { ensureDirectoryExists } = await import(\"./utils\");\n    const outputDir = currentConfig.outputPaths.fileTree.split(\"/\").slice(0, -1).join(\"/\");\n    await ensureDirectoryExists(vscode.Uri.joinPath(workspaceRoot, outputDir || \"docs\"));\n    await safeGenerateAndWriteFileTree(workspaceRoot, generateFileTree);\n    let genOnceArch = false;\n    await vscode.window.withProgress(\n      {\n        location: vscode.ProgressLocation.Notification,\n        title: \"ASCII Agent\",\n        cancellable: true,\n      },\n      async (progress, archToken) => {\n        genOnceArch = await safeGenerateArchitecture(workspaceRoot, progress, archToken);\n      },\n    );\n    if (genOnceArch) {\n      vscode.window.showInformationMessage(\n        'ASCII Agent: Diagrams generated. Run \"ASCII Agent: Toggle Auto-Watch\" any time to enable automatic updates.',\n      );\n    } else {\n      vscode.window.showWarningMessage(\n        'ASCII Agent: File tree created. Architecture diagram skipped \u2014 Copilot not available yet. Run \"ASCII Agent: Generate Now\" once Copilot is ready.',\n      );\n    }\n  } else {\n    log.info(\"Welcome prompt: dismissed by user.\");\n  }\n}\n", "/**\n * @file token-tracker.ts\n * @description Lightweight token-usage accounting for ASCII Agent LM requests.\n *\n * The VS Code LM API does not expose exact token counts from streamed responses,\n * so this module uses character-count heuristics (~4 chars per token) to produce\n * estimates. These are \"good enough\" for surfacing rough cost awareness, not for\n * billing accuracy.\n *\n * Two tallies are maintained:\n * - **Session** \u2014 persisted in `ExtensionContext.globalState` under a well-known key but reset\n *   to zero on every extension activation, so it reflects only the current window's usage.\n * - **Lifetime** \u2014 persisted across sessions in `ExtensionContext.globalState`.\n *\n * All public functions are pure side-effects through `globalState`; no module-level\n * mutable state is held here to avoid circular dependencies.\n */\n\nimport * as vscode from \"vscode\";\nimport type { TokenUsageTotals } from \"./types\";\nimport { log } from \"./logger\";\n\n// ---------------------------------------------------------------------------\n// Storage keys\n// ---------------------------------------------------------------------------\n\nconst LIFETIME_KEY = \"asciiAgent.tokenUsage.lifetime\";\nconst SESSION_KEY = \"asciiAgent.tokenUsage.session\";\n\n// ---------------------------------------------------------------------------\n// Public API\n// ---------------------------------------------------------------------------\n\n/**\n * Record a completed LM request's estimated token usage.\n *\n * Increments both the in-memory session tally and the persisted lifetime tally.\n * Logs a one-line summary to the ASCII Agent output channel.\n *\n * @param context              - Extension context providing `globalState` persistence.\n * @param inputTokensEstimate  - Estimated number of input (prompt) tokens consumed.\n * @param outputTokensEstimate - Estimated number of output (completion) tokens produced.\n */\nexport async function recordTokenUsage(\n  context: vscode.ExtensionContext,\n  inputTokensEstimate: number,\n  outputTokensEstimate: number,\n): Promise<void> {\n  const session = getSessionTokenUsage(context);\n  const newSession: TokenUsageTotals = {\n    inputTokensEstimate: session.inputTokensEstimate + inputTokensEstimate,\n    outputTokensEstimate: session.outputTokensEstimate + outputTokensEstimate,\n    requestCount: session.requestCount + 1,\n  };\n  await context.globalState.update(SESSION_KEY, newSession);\n\n  const lifetime = getLifetimeTokenUsage(context);\n  const newLifetime: TokenUsageTotals = {\n    inputTokensEstimate: lifetime.inputTokensEstimate + inputTokensEstimate,\n    outputTokensEstimate: lifetime.outputTokensEstimate + outputTokensEstimate,\n    requestCount: lifetime.requestCount + 1,\n  };\n  await context.globalState.update(LIFETIME_KEY, newLifetime);\n\n  log.info(\n    `Token usage \u2014 request: ~${inputTokensEstimate} in / ~${outputTokensEstimate} out` +\n      ` | session total: ~${newSession.inputTokensEstimate + newSession.outputTokensEstimate} tokens` +\n      ` (${newSession.requestCount} requests)` +\n      ` | lifetime: ~${newLifetime.inputTokensEstimate + newLifetime.outputTokensEstimate} tokens` +\n      ` (${newLifetime.requestCount} requests)`,\n  );\n}\n\n/**\n * Reset the session token tally.\n * Should be called at the start of each extension activation.\n *\n * @param context - Extension context providing `globalState`.\n */\nexport async function resetSessionTokens(context: vscode.ExtensionContext): Promise<void> {\n  await context.globalState.update(SESSION_KEY, {\n    inputTokensEstimate: 0,\n    outputTokensEstimate: 0,\n    requestCount: 0,\n  });\n}\n\n/**\n * Return the current session token usage totals.\n * Resets to zero on each extension activation.\n *\n * @param context - Extension context providing `globalState`.\n */\nexport function getSessionTokenUsage(context: vscode.ExtensionContext): TokenUsageTotals {\n  return context.globalState.get<TokenUsageTotals>(SESSION_KEY) ?? emptyTotals();\n}\n\n/**\n * Return the persisted lifetime token usage totals.\n * Accumulates across all sessions until manually reset.\n *\n * @param context - Extension context providing `globalState`.\n */\nexport function getLifetimeTokenUsage(context: vscode.ExtensionContext): TokenUsageTotals {\n  return context.globalState.get<TokenUsageTotals>(LIFETIME_KEY) ?? emptyTotals();\n}\n\n// ---------------------------------------------------------------------------\n// Helpers\n// ---------------------------------------------------------------------------\n\n/** Zero-value `TokenUsageTotals`. */\nfunction emptyTotals(): TokenUsageTotals {\n  return { inputTokensEstimate: 0, outputTokensEstimate: 0, requestCount: 0 };\n}\n"],
  "mappings": "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",
  "names": ["vscode", "vscode", "vscode", "vscode", "vscode", "vscode", "vscode", "generateFileTree", "ensureDirectoryExists", "cancelPendingTimers", "generateArchitectureDiagram", "createLmClient", "saveSnapshot", "startWatching", "elapsed", "pruneSnapshots", "getDefaultConfig"]
}
